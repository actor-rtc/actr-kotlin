syntax = "proto2";

package actr;

import "google/protobuf/timestamp.proto";

// ===========================================================================
// Basic Components
//   Realm (Security Realm)
//   ActrType (manufacturer + name)
//   ActrId (Realm + serial number + type)
//   ServiceSpec (fingerprint + proto bundle + tags)
//   ActrNode (ActrId + ServiceSpec)
// ===========================================================================
message Realm {
  required uint32 realm_id = 1;
}

message ActrType {
  required string manufacturer = 1;
  required string name = 2;
}

message ActrId {
  required Realm realm = 1;
  required uint64 serial_number = 2;
  required ActrType type = 3;
}

message ServiceSpec {
  optional string description = 1;
  required string fingerprint = 2; // Deterministic hash combining all proto semantic fingerprints
  repeated Protobuf protobufs = 3;
  optional int64 published_at = 4; // Publication timestamp (Unix epoch seconds)
  repeated string tags = 5; // Tags like "latest", "stable"

  message Protobuf {
    required string package = 1;   // Package name (e.g., "user.v1", "acme.payment.v2")
    required string content = 2;   // Merged and normalized content for this package
    required string fingerprint = 3; // Semantic fingerprint of merged package content
  }
}

message ActrNode {
  required ActrId actr_id = 1;
  optional ServiceSpec service_spec = 2;
}

// Geographic location for load balancing
message ServiceLocation {
  optional string region = 1;      // Region identifier (e.g., "us-west", "cn-beijing")
  optional double latitude = 2;    // Latitude in decimal degrees (-90 to +90)
  optional double longitude = 3;   // Longitude in decimal degrees (-180 to +180)
}

// ============================================================================
// AId Credential
// ============================================================================

// Credential structure for ActrId authentication
message AIdCredential {
  required bytes encrypted_token = 1;
  required uint32 token_key_id = 2;
}

// ============================================================================
// Access Control (type-to-type permissions)
// =========================================================================

// A single ACL rule: from -> me : permission
message AclRule {
  message Principal {
    optional Realm realm = 1;
    optional ActrType actr_type = 2;
  }

  repeated Principal principals = 1;

  enum Permission { DENY = 0; ALLOW = 1; }
  required Permission permission = 2;
}

// Access Control List (ordered; first match wins)
message Acl {
  repeated AclRule rules = 1;
}

// =========================================================================
// Actr States
//   LifecycleState: ActrNode Lifecycle State
//   ServiceAvailabilityState: ActrNode Availability State
//   ServiceDependencyState: ActrNode Service Dependency State
// =========================================================================

enum LifecycleState {
  HALTED = 0;
  INITIALIZING = 1;
  CONSTRUCTING = 2;
  RUNNING = 3;
  DESTRUCTING = 4;
  CRASHING = 5;
}

enum ServiceAvailabilityState {
  FULL = 0;
  DEGRADED = 1;
  OVERLOADED = 2;
  UNAVAILABLE = 3;
}

enum ServiceDependencyState {
  HEALTHY = 0;
  WARNING = 1;
  BROKEN = 2;
}

// ============================================================================
// Common Error (copied from actr/common.proto)
// ============================================================================

message ErrorResponse {
  required uint32 code = 1;
  required string message = 2;
}

// =========================================================================
// Register
// =========================================================================
// Allocate a new ActrId and register node metadata and API info.
message RegisterRequest {
  required ActrType actr_type = 1;
  required Realm realm = 2;

  // API / contract metadata
  optional ServiceSpec service_spec = 3;
  optional Acl acl = 4;
}

message RegisterResponse {
  message RegisterOk {
    // Allocated identity and credentials
    required ActrId actr_id = 1;
    required AIdCredential credential = 2;
    optional bytes psk = 3; // bootstrap keying material
    optional google.protobuf.Timestamp credential_expires_at = 4;
    // Operational advice: heartbeat interval for subsequent Signaling Server connection
    required uint32 signaling_heartbeat_interval_secs = 5;
  }
  oneof result {
    RegisterOk success = 1;
    ErrorResponse error = 2;
  }
}

// ============================================================================
// Credential Update
// ============================================================================

message CredentialUpdateRequest {
  required ActrId actr_id = 1;
}

// ============================================================================
// Unregister
// ============================================================================

message UnregisterRequest {
  required ActrId actr_id = 1;
  optional string reason = 2;
}

message UnregisterResponse {
  message UnregisterOk {}
  oneof result {
    UnregisterOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Heartbeat
// =========================================================================
// Periodic liveness and load indicators.
// NOTE: Currently measures Node-to-Signaling latency only.
// For P2P latency-based routing, consider adding:
//   - optional uint64 signaling_rtt_ms = 4;  // Node-to-Signaling RTT
//   - LatencyReport message for P2P measurements
// See RouteCandidatesRequest.LOWEST_LATENCY for design discussion.
message Ping {
  required ServiceAvailabilityState availability = 1;
  required float power_reserve = 2;
  required float mailbox_backlog = 3;

  // Sticky session support: list of client IDs that must route to this instance.
  // Used by LoadBalancer's CLIENT_AFFINITY factor for session persistence.
  // Actor instances report their currently connected sticky clients.
  repeated string sticky_client_ids = 4;
}

message Pong {
  required uint64 seq = 1;
  optional uint32 suggest_interval_secs = 2; // advisory
}

// =========================================================================
// Load-balancing: find best route candidates
// =========================================================================
// Request route candidates for a target actor type with optional selection policy.
message RouteCandidatesRequest {
  message NodeSelectionCriteria {
    // Ranking factors for candidate ordering
    enum NodeRankingFactor {
      MAXIMUM_POWER_RESERVE = 0;
      MINIMUM_MAILBOX_BACKLOG = 1;
      BEST_COMPATIBILITY = 2;
      NEAREST = 3;
      CLIENT_AFFINITY = 4;
    }

    required uint32 candidate_count = 1;
    repeated NodeRankingFactor ranking_factors = 2;
    optional ServiceDependencyState minimal_dependency_requirement = 3;
    optional ServiceAvailabilityState minimal_health_requirement = 4;
  }
  required ActrType target_type = 1;
  optional NodeSelectionCriteria criteria = 2;
  optional ServiceLocation client_location = 3;  // Client's geographic location for NEAREST ranking
}

message RouteCandidatesResponse {
  message RouteCandidatesOk {
    repeated ActrId candidates = 1;
  }
  oneof result {
    RouteCandidatesOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Discovery request/response
// =========================================================================
// List (ActrType x fingerprint) combinations present on the network.
message DiscoveryRequest {
  optional string manufacturer = 1;
  optional uint32 limit = 2 [default = 64];
}

message DiscoveryResponse {
  message TypeEntry {
    required ActrType actr_type = 1;
    optional string description = 2;
    required string service_fingerprint = 3;
    optional int64 published_at = 4;
    repeated string tags = 5;
  }

  message DiscoveryOk {
    repeated TypeEntry entries = 1;
  }

  oneof result {
    DiscoveryOk success = 1;
    ErrorResponse error = 2;
  }
}

// =========================================================================
// Actr-up subscription (push-based presence by actor instance)
// =========================================================================

// Subscribe to "actor of target_type comes online" events.
message SubscribeActrUpRequest {
  required ActrType target_type = 1;
}

message SubscribeActrUpResponse {
  message SubscribeOk {}
  oneof result {
    SubscribeOk success = 1;
    ErrorResponse error = 2;
  }
}

// Cancel a previous subscription.
message UnsubscribeActrUpRequest {
  required ActrType target_type = 1;
}

message UnsubscribeActrUpResponse {
  message UnsubscribeOk {}
  oneof result {
    UnsubscribeOk success = 1;
    ErrorResponse error = 2;
  }
}

// Event: a matching actor instance changed presence.
message ActrUpEvent {
  required ActrId actor_id = 1;
}

// =========================================================================
// WebRTC Role Negotiation
// =========================================================================

// Initiate role arbitration between two Actr peers (who will create the Offer)
message RoleNegotiation {
  required ActrId from = 1;
  required ActrId to = 2;
  required uint32 realm_id = 3;
}

// Signaling server assigns the offerer role to one side
message RoleAssignment {
  required bool is_offerer = 1;
}
